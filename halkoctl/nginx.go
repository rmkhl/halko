package main

import (
	"errors"
	"flag"
	"fmt"
	"os"
)

func showNginxHelp() {
	fmt.Println("halkoctl nginx - Generate nginx proxy configuration")
	fmt.Println()
	fmt.Println("Generates an nginx configuration file to proxy Halko services under /api/v1.")
	fmt.Println("The configuration assumes a single server setup without virtual hosts.")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Printf("  %s nginx [options]\n", os.Args[0])
	fmt.Println()
	fmt.Println("Options:")
	fmt.Println("  -port int")
	fmt.Println("        Port for nginx to listen on (default: 80)")
	fmt.Println("  -output string")
	fmt.Println("        Output file path (default: stdout)")
	fmt.Println("  -h, --help")
	fmt.Println("        Show this help message")
	fmt.Println()
	fmt.Println("Examples:")
	fmt.Printf("  %s nginx -port 8080\n", os.Args[0])
	fmt.Printf("  %s nginx -port 80 -output /etc/nginx/sites-available/halko\n", os.Args[0])
}

func handleNginxCommand() {
	nginxFlags := flag.NewFlagSet("nginx", flag.ExitOnError)
	port := nginxFlags.Int("port", 80, "Port for nginx to listen on")
	output := nginxFlags.String("output", "", "Output file path (default: stdout)")

	if err := nginxFlags.Parse(os.Args[2:]); err != nil {
		fmt.Fprintf(os.Stderr, "Error: Failed to parse flags: %v\n", err)
		os.Exit(exitError)
	}

	config := globalConfig
	if config == nil {
		fmt.Fprintf(os.Stderr, "Error: Configuration not loaded\n")
		os.Exit(exitError)
	}

	// Extract host:port from configuration URLs
	controlunitHost, controlunitPort, err := extractHostPort(config.APIEndpoints.ControlUnit.URL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: Failed to parse controlunit URL: %v\n", err)
		os.Exit(exitError)
	}

	sensorHost, sensorPort, err := extractHostPort(config.APIEndpoints.SensorUnit.URL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: Failed to parse sensorunit URL: %v\n", err)
		os.Exit(exitError)
	}

	powerHost, powerPort, err := extractHostPort(config.APIEndpoints.PowerUnit.URL)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: Failed to parse powerunit URL: %v\n", err)
		os.Exit(exitError)
	}

	nginxConfig := generateNginxConfig(*port, controlunitHost, controlunitPort, sensorHost, sensorPort, powerHost, powerPort)

	if *output == "" {
		fmt.Print(nginxConfig)
	} else {
		err := os.WriteFile(*output, []byte(nginxConfig), 0644)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: Failed to write to %s: %v\n", *output, err)
			os.Exit(exitError)
		}
		fmt.Printf("Nginx configuration written to %s\n", *output)
	}
}

func extractHostPort(urlStr string) (string, string, error) {
	// Parse URL and extract hostname and port
	if urlStr == "" {
		return "", "", errors.New("empty URL")
	}

	// Simple parsing - extract from http://host:port format
	var host, port string
	if _, err := fmt.Sscanf(urlStr, "http://%s", &host); err != nil {
		return "", "", fmt.Errorf("invalid URL format: %s", urlStr)
	}

	// Split host:port
	for i := len(host) - 1; i >= 0; i-- {
		if host[i] == ':' {
			port = host[i+1:]
			host = host[:i]
			break
		}
	}

	if port == "" {
		port = "80"
	}

	return host, port, nil
}

func generateNginxConfig(listenPort int, controlunitHost, controlunitPort, sensorHost, sensorPort, powerHost, powerPort string) string {
	return fmt.Sprintf(`# Halko nginx proxy configuration
# Generated by halkoctl

server {
    listen %d;
    server_name _;

    # Serve static web application files
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
    }

    # Proxy for controlunit service (includes storage endpoints)
    location /api/v1/controlunit/ {
        proxy_pass http://%s:%s/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # CORS headers
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
        add_header Access-Control-Allow-Headers "Origin, Content-Type";

        if ($request_method = OPTIONS) {
            return 204;
        }
    }

    # Proxy for sensorunit service
    location /api/v1/sensorunit/ {
        proxy_pass http://%s:%s/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # CORS headers
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
        add_header Access-Control-Allow-Headers "Origin, Content-Type";

        if ($request_method = OPTIONS) {
            return 204;
        }
    }

    # Proxy for powerunit service
    location /api/v1/powerunit/ {
        proxy_pass http://%s:%s/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # CORS headers
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
        add_header Access-Control-Allow-Headers "Origin, Content-Type";

        if ($request_method = OPTIONS) {
            return 204;
        }
    }

    # Error pages
    error_page 502 503 504 /50x.html;
    location = /50x.html {
        root /usr/share/nginx/html;
    }
}
`, listenPort, controlunitHost, controlunitPort, sensorHost, sensorPort, powerHost, powerPort)
}
